/// The `Eq` interface enables equality comparisons for types for which support it.
interface Eq[A] {

  /// Compares `a1` and `a2` for equality.
  /// @return `true` if they are equal, `false` otherwise.
  fun eq (a1 :A, a2 :A) :Bool

  /// Computes the inverse of `eq` on `a1` and `a2`.
  /// @return `false` if they are equal, `true` otherwise.
  fun notEq (a1 :A, a2 :A) :Bool
}

fun defNotEq[A:Eq](a1 :A, a2 :A) :Bool = !eq(a1, a2)

// fun voidEq (v1 :Void, v2 :Void) :Bool = true
// impl eqVoid = Eq[Void](eq=voidEq, notEq=defNotEq)

// fun unitEq (u1 :Unit, u2 :Unit) :Bool = true
// impl eqUnit = Eq[Unit](eq=unitEq, notEq=defNotEq)

// fun boolEq (a :Bool, b :Bool) :Bool = foreign
// impl eqBool = Eq[Bool](eq=boolEq, notEq=defNotEq)

fun i32Eq (a :I32, b :I32) :Bool = foreign
impl eqI32 = Eq[I32](eq=i32Eq, notEq=defNotEq)

fun arrayEq[A:Eq] (a1 :Array[A], a2 :Array[A]) :Bool = {
  fun loop (ii :I32) :Bool =
    if (ii == a1.length) true
    else if (a1@ii != a2@ii) false
    else loop(ii+1)
  if (a1.length == a2.length) loop(0) else false
}
impl eqArray[A:Eq] = Eq[Array[A]](eq=arrayEq, notEq=defNotEq)

fun test (a1 :Array[I32], a2 :Array[I32]) :Bool = a1 == a2

// fun test (a1 :Array[Bool], a2 :Array[Bool]) :Bool = a1 == a2
