//
// Compose Mark 0 compiler
// https://github.com/samskivert/compose/c0/LICENSE

package compose

import org.junit.Assert._
import org.junit._

class LowerTest {
  import Lower._
  import TestCode._

  val PrintLoweredTrees = false

  def check (trees :Seq[Tree]) :Unit = {
    if (PrintLoweredTrees) trees foreach print
    assertFalse("No trees generated by lower?", trees.isEmpty)
  }

  def lowerTrees (trees :Seq[Trees.Tree]) :Seq[Tree] = {
    val errs = trees.flatMap(Trees.errors)
    if (errs.isEmpty) lower(trees)
    else {
      errs foreach { case (path, err) =>
        println(s"Error: $err @ ${Trees.show(path.head)}")
        path foreach { t => println(s"- ${Trees.show(t)} : ${t.productPrefix}") }
      }
      fail("Trees had errors")
    }
  }

  def lowerCode (code :String) = lowerTrees(typeCode("code", code))

  @Test def testCondFib () :Unit = check(lowerCode(CondFib))
  @Test def testMatchFib () :Unit = check(lowerCode(MatchFib))

  @Test def testBindBlock () :Unit = check(lowerCode("""
    fun add (a :I32, b :I32) :I32 = 0
    fun less (a :I32, b :I32) :Bool = false
    var a = if true 1 else 2
    let b = if {
      let a = 1
      a + a < 5
    } 1 else 2
    let c = {
      let a = 1
      a + a
    }
  """))

  @Test def testIgnore () :Unit = check(lowerCode("""
    fun less (a :I32, b :I32) :Bool = false
    fun add (a :I32, b :I32) :I32 = 0
    var ii = 0
    while (ii < 10) ii = ii + (if (ii < 5) 1 else 2)
  """))

  @Test def testForeigns () :Unit = check(lowerCode("""
    let Zero :I32 = foreign("0")
    fun length[A] (as :Array[A]) :I32 = foreign("as.length")
    fun clear[A] (as :Array[A]) :Unit = foreignBody("as.length = 0")
  """))

  @Test def testParenBlock () :Unit = check(lowerCode(ParenBlock))

  @Test def testApplyImpl () :Unit = check(lowerCode(ApplyImpl))

  @Test def testStdlib () :Unit = check(lowerTrees(typeFiles(StdlibFiles)))

  @Test def testSemigroup () :Unit =
    check(lowerTrees(typeFiles(Seq("std/prelude.cz", "std/semigroup.cz"))))

  @Test def testSimpleMatch () :Unit = check(lowerCode(SimpleMatch))
  @Test def testTupleMatch () :Unit = check(lowerCode(TupleMatch))
  @Test def testDestructMatch () :Unit = check(lowerCode(DestructMatch))
  @Test def testParamDestructMatch () :Unit = check(lowerCode(ParamDestructMatch))
  @Test def testGuardedMatch () :Unit = check(lowerCode(GuardedMatch))

  @Test def testForeignOps () :Unit = check(lowerCode(ForeignOps))
}
