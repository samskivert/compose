<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Goals | Compose</title>
    <link rel="stylesheet" href="/compose/css/style.css" />
    <link rel="stylesheet" href="/compose/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/compose/">Overview</a></li>
      
      <li><a href="/compose/goals/">Goals</a></li>
      
      <li><a href="/compose/faq/">FAQ</a></li>
      
      <li><a href="https://github.com/samskivert/compose">Github</a></li>
      
    </ul>
    </nav>
    <div class="title">Compose</div>
    <hr/>

<div class="article-meta">


<h1><span class="title">Goals</span></h1>
</div>

<main>


<blockquote>
<p>It must be borne in mind that the tragedy of life doesn’t lie in not reaching your goal. The
tragedy lies in having no goals to reach.” — Benjamin E. Mays</p>
</blockquote>

<p>I have many goals for Compose, some radical, some mundane. Enumerating them here serves to convey
my aims until that job can be done by a working prototype. Communicating the goals also helps me to
clarify them to myself. Hello self!</p>

<p>Some of these goals are nebulous and will require research to further clarify and achieve; some are
straightforward and &ldquo;merely&rdquo; require a lot of engineering work. In the fullness of time I hope to
address them all, as my overarching goal is for Compose to be used (at least by me) to build real
software that improves the world, not just a research prototype.</p>

<blockquote>
<p>Note: this list is in-progress and incomplete.</p>
</blockquote>

<h2 id="programming-model">Programming model</h2>

<h3 id="functional-core">Functional core</h3>

<ul>
<li><p>Strict functional core language. Possibly with local impurity (for those times when a while loop
is just much clearer than tail recursion).</p></li>

<li><p>Sums and products (algebraic data types) for composing scalar data into structures.</p></li>

<li><p>Type classes for ad-hoc polymorphism, including a standard library of the <a href="https://wiki.haskell.org/Typeclassopedia">usual suspects</a>. See
the <a href="../faq/">FAQ</a> for some ranting on why no OOP. I have vague goals to incorporate aspects of
ML-style modules, but they are insufficiently baked and I cannot yet describe them.</p></li>

<li><p>Effects: possibly modeled through <a href="https://arxiv.org/abs/1611.09259">Frank</a>-like effects system, possibly modeled through
&ldquo;capability arguments&rdquo;, possibly something else. I&rsquo;m really hoping <em>not</em> to model them via
<a href="https://github.com/haskell/mtl">MTL</a>-style type class boilerplate.</p></li>

<li><p>&ldquo;Rule-abiding&rdquo; numeric types (arbitrary size naturals and integers, and arbitrary precision
decimals) for when semantics are more important than performance. I plan to be very explicit
about the types which prioritize performance over semantics. For example, there will be no <code>int</code>
type, there will be a &lsquo;32-bit signed twos-complement integer&rsquo; type, which wears its particular
semantics on its sleeve.</p></li>

<li><p>I will probably also include a &ldquo;reasonably performant numeric type that has neither precise
semantics nor precise performance characteristics, but will probably do what you want as long as
your numbers aren&rsquo;t too big&rdquo; abstraction to paper over the annoying variety in the backends I
hope to eventually support (some subset of JavaScript, WebAssembly, JVM, CLR, LLVM).</p></li>

<li><p><code>String</code> will be an abstraction, rather than a concrete data type, so that the privileged
representation for a particular backend platform can be used by default.</p></li>
</ul>

<h3 id="reactive-dataflow">Reactive / dataflow</h3>

<ul>
<li><p>The standard library, the environment, and potentially the language, will provide tools for
&ldquo;reactive&rdquo; programming.</p></li>

<li><p>My design is somewhere in between the stateful one-way dataflow (popularized by <a href="https://reactjs.org/">React</a> and
<a href="http://elm-lang.org/">Elm</a>), and the &ldquo;everything is a fold over streams&rdquo; higher-order FRP more common in pure
functional languages (like the <a href="https://github.com/reflex-frp/reflex">Reflex</a> library). I described my ideas as <a href="http://samskivert.com/blog/2013/11/thinking-aloud-rsp/">RSP</a> a few years ago,
but things will likely evolve from there when actually implemented.</p></li>
</ul>

<h3 id="datalog">Datalog</h3>

<ul>
<li>I&rsquo;m intrigued by the pervasive decoupling enabled by datalog-style programming (see this
exposition of its use in <a href="https://rsnous.com/posts/notes-from-dynamicland-geokit/#background-on-realtalk">RealTalk</a>), but I need to experiment more with it before understanding
how much it would benefit from being deeply integrated into the language.</li>
</ul>

<h2 id="syntax-and-type-checking">Syntax and type checking</h2>

<ul>
<li><p>Serialized ASTs, not text.</p></li>

<li><p>Edit the AST not a grid of characters.</p>

<ul>
<li>Syntax errors become impossible.</li>
</ul></li>

<li><p>The AST is type checked as you create it. Type inference is a conversation between you and the
compiler, the results of which are recorded as type annotations. It&rsquo;s not a fragile process
repeated every time a program is compiled.</p></li>

<li><p>Visualize the AST, rather than a grid of characters.</p>

<ul>
<li>Type annotations exist but need not always be shown. The developer can decide what to show by
default, what to show interactively, etc.</li>
</ul></li>
</ul>

<h2 id="refactoring">Refactoring</h2>

<ul>
<li><p>Names are merely annotations for humans. Changing them does not change the structure of the code
and requires no changes to any code using the changed definition.</p></li>

<li><p>AST edits capture more semantic information than textual edits. That information can be used to
construct patches which are automatically or interactively applied to callers of the changed
code.</p>

<ul>
<li>For example, adding an additional argument to a function could also capture a default. When a
user of the changed library updates their dependency, it could trigger an automatic or
interactive patching process which applies that default argument to all calls, allowing the
user to inspect each call site and accept the default or make an alternative choice.</li>
<li>As another example, factoring some functions and data structures into a sub-module should not
require manual repair by calling code. The change in provenance can be recorded and applied
automatically or interactively when calling code upgrades to the new version of a library.</li>
</ul></li>
</ul>

<h2 id="code-organization">Code organization</h2>

<ul>
<li><p>Many languages prescribe some aspects of code organization, but leave other aspects undefined.
Build systems and the community have to come up with ad-hoc tooling to finish the job. Compose
will define a complete model that spans entire projects down to individual expressions, and
includes additional concepts needed by the actual development process. I have a separate page
with details on the <a href="../project-model/">project model</a>.</p></li>

<li><p>Code is a hypertext and there are many ways to organize and view it, explicitly and implicitly.
By eliminating &ldquo;text in source files&rdquo; as an implementation artifact, I aim to shift the focus
away from the incidental organization it implies (the order in which definitions appear in a
file, the name of the file, the names of directories that contain the source files) and toward
explicit semantic organization. This can be expressed by the original author (grouping
definitions into modules, for example), or created dynamically to solve a problem at hand (show
all definitions used by a particular function, or show all definitions that call a particular
function), or because there are simply multiple useful ways to organize code (show only the
exported definitions of a module, or group of modules, show code not reached by any test code,
show definitions alphabetically or in &lsquo;curated&rsquo; order).</p></li>
</ul>

<h2 id="documentation">Documentation</h2>

<ul>
<li><p>Documentation is a first-class citizen. It is structured (has its own simple AST), checked (can
contain references to definitions which are &ldquo;live&rdquo;), and can contain embedded &ldquo;live&rdquo; code
examples (real checked and compiled code running on real data).</p></li>

<li><p>Detailed documentation and executable code examples can appear &ldquo;next to&rdquo; the code in question.
Because we&rsquo;re not limited to static text files, a library author can simply denote code as being
example code and the editor/environment can surface appropriate example code for any function or
data structure on demand.</p></li>

<li><p>A project should be able to include <em>all</em> of its documentation. Documentation should not be split
across an overview/examples website, generated API documentation and the code itself. Overview
documentation, tutorials, examples, everything should be able to live inside the project and
benefit from the structure, checking and liveness that one has when reading code in an IDE.</p></li>
</ul>

<h2 id="testing">Testing</h2>

<ul>
<li><p>Unit testing will be &ldquo;built-in&rdquo; and will benefit from the ability to easily expose dynamic views
of the codebase. Because the compiler infrastructure will be readily available to the unit
testing infrastructure, automatically running &ldquo;affected&rdquo; unit tests on changes should be
straightforward. Test feedback should be as automatic and &ldquo;ambient&rdquo; as type feedback is in a good
IDE.</p></li>

<li><p>Integration testing will likely manifest as additional application/executable project components.
An integration test is a built artifact, just like an application. It may prove more challenging
to manage the actual execution of said integration tests due to the necessity of integrating with
production or staging environments and the myriad moving parts that come with actual deployment.
It&rsquo;s something that will have to evolve as we obtain experience with building real apps.</p></li>
</ul>

<h2 id="building">Building</h2>

<ul>
<li><p>TODO: Patching of library dependencies.</p></li>

<li><p>TODO: Build specification &amp; extension mechanism built-in.</p></li>
</ul>

<h2 id="debugging">Debugging</h2>

<ul>
<li><p>Streamlined mechanism for tracing expressions and function calls: can take the form of logging,
or a &lsquo;watched variable&rsquo; like a debugger, or a visual display like a graph of a numeric value. The
potential exists for fancier visualizations, but I&rsquo;d like to start with the low hanging fruit.</p></li>

<li><p>The reactive state model will support inspecting/visualizing that state during program execution
(and after, for state that can persist across executions). But I would like to also visualize
state dependencies, and changes as they propagate through the data flow graph.</p></li>

<li><p>&hellip; TODO &hellip;</p></li>
</ul>

<h2 id="editing-and-tooling">Editing and Tooling</h2>

<ul>
<li><p>Because Compose is oriented around modules and definitions, rather than files, the editing
experience will be more like <a href="http://cs.brown.edu/~spr/codebubbles/">Code Bubbles</a> than <a href="https://code.visualstudio.com/">Visual Studio</a>. I&rsquo;m currently leaning toward
something slightly less free-form than Code Bubbles, but you&rsquo;ll still have a lot of flexibility
in arranging your workspace based on your problem at hand and not based on the incidental
structure of characters, text files and directories.</p></li>

<li><p>&hellip; TODO &hellip;</p></li>
</ul>

<h2 id="version-control">Version control</h2>

<ul>
<li>&hellip; TODO &hellip;</li>
</ul>

<h2 id="code-visualization">Code visualization</h2>

<ul>
<li>&hellip; TODO &hellip;</li>
</ul>

<h2 id="learning">Learning</h2>

<ul>
<li><p>Use mathematics terminology and symbols where appropriate, to leverage students (and adults)
prior investment in that &ldquo;language&rdquo;.</p></li>

<li><p>The editing environment can be tailored to show more or less contextual help based on the skill
level of its user. This may manifest as preference toggles for myriad help mechanisms (e.g. show
types on locals, show key bindings, verbose type error hints), also controllable via
coarse-grained &ldquo;beginner, intermediate, advanced&rdquo; presets, or perhaps something fancier.</p></li>

<li><p>TODO: learnable key bindings</p></li>
</ul>

<h3 id="microworlds">Microworlds</h3>

<ul>
<li><p>To enable a focus on specific concepts, I aim to create <a href="http://edutechwiki.unige.ch/en/Microworld">microworlds</a> which combine a restricted
set of functional building blocks with a high-level simulation or framework. The simulation will
be embedded in the editor so that the entire experience takes place in the single unified
environment.</p></li>

<li><p>For example: a 2D drawing microworld provides functions that describe simple geometric shapes
(possibly evolving over time) for a built-in framework that draws and animates the shapes.
Similar in the spirit to the <a href="http://outreach.mcmaster.ca/tools/ShapeCreator.html">ShapeCreator</a> created for the <a href="http://outreach.mcmaster.ca/what-we-do.html">Elm Graphics</a> program at McMaster
University. This focuses on the concepts of function composition (chaining functions to create a
particular shape), function reuse (encapsulating a shape into a function and reusing it in larger
shapes), looping/repetition (repeatedly calling a function with slightly different parameters).</p></li>

<li><p>Another example: a simulated robot moving around an environment (ala <a href="http://www.robotturtles.com/">Robot Turtles</a> or
<a href="http://lightbot.com/">LightBot</a>) which the student controls by creating a list of instructions. &ldquo;Instruction&rdquo;
functions compute a new state for the robot based on its current state and &ldquo;sensor&rdquo; data from the
environment. This can focus on the concept of sequenced computations (executing one instruction
after another), and on the concept of an abstract state which represents an evolving entity.</p></li>

<li><p>More advanced microworlds can focus on more abstract scenarios like computing and graphing
arithmetic expressions, transforming and processing data, creating simple user interfaces. They
would all leverage the ability to embed the target application in the editing environment, and
the ability to restrict the editing environment to just a <a href="https://scratch.mit.edu/">Scratch</a>-like palette of relevant
(functional and structural) building blocks.</p></li>

<li><p>As the students projects scale up in complexity, they are able to leverage the organizational
features of Compose and its editing environment just as a professional programmer would. They can
define their own data types, group code and data into modules, document and test their code. Many
of these capabilities are lacking in traditional pedagogical programming environments, which can
lead to frustration and miss an opportunity to educate the student on good practices for dealing
with the inevitable complexity that comes from larger programs.</p></li>
</ul>

</main>

  <footer>
  
  
  <hr/>
  &copy; 2018 <a href="http://samskivert.com">Michael Bayne</a>
  
  </footer>
  </body>
</html>

